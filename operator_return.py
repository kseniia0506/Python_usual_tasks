# Функции могут передавать какие-либо данные из своих тел в основную ветку программы.
# Говорят, что функция возвращает значение. В большинстве языков программирования, в том числе Python,
# выход из функции и передача данных в то место, откуда она была вызвана, выполняется оператором return.

# Если интерпретатор Питона, выполняя тело функции, встречает return, то он "забирает" значение,
# указанное после этой команды, и "уходит" из функции.

def cylinder():
    r = float(input())
    h = float(input())
    # площадь боковой поверхности цилиндра:
    side = 2 * 3.14 * r * h
    # площадь одного основания цилиндра:
    circle = 3.14 * r ** 2
    # полная площадь цилиндра:
    full = side + 2 * circle
    return full


square = cylinder()
print(square)


# Пример выполнения:

# 3
# 7
# 188.4
# В данной программе в основную ветку из функции возвращается значение локальной переменной full.
# Не сама переменная, а ее значение, в данном случае – какое-либо число, полученное в результате вычисления
# площади цилиндра.

# В основной ветке программы это значение присваивается глобальной переменной square.
# То есть выражение square = cylinder() выполняется так:

# Вызывается функция cylinder().
# Из нее возвращается значение.
# Это значение присваивается переменной square.
# Не обязательно присваивать результат переменной, его можно сразу вывести на экран:

# print(cylinder())
# Здесь число, полученное из cylinder(), непосредственно передается функции print().
# Если мы в программе просто напишем cylinder(), не присвоив полученные данные переменной или не передав их куда-либо дальше, то эти данные будут потеряны. Но синтаксической ошибки не будет.

# В функции может быть несколько операторов return. Однако всегда выполняется только один из них.
# Тот, которого первым достигнет поток выполнения. Допустим, мы решили обработать исключение,
# возникающее на некорректный ввод. Пусть тогда в ветке except обработчика исключений происходит выход из функции
# без всяких вычислений и передачи значения:

def cylinder():
    try:
        r = float(input())
        h = float(input())
    except ValueError:
        return
    side = 2 * 3.14 * r * h
    circle = 3.14 * r ** 2
    full = side + 2 * circle
    return full


print(cylinder())

# Если попытаться вместо цифр ввести буквы, то сработает return, вложенный в except.
# Он завершит выполнение функции, так что все нижеследующие вычисления, в том числе return full, будут опущены.
# Пример выполнения:

r
None


# Но постойте! Что это за слово None, которое нам вернул "пустой" return? Это ничего, такой объект – "ничто".
# Он принадлежит классу NoneType. До этого мы знали четыре типа данных, они же четыре класса: int, float, str, bool.
# Пришло время пятого.

# Когда после return ничего не указывается, то по умолчанию считается, что там стоит объект None.
# Но никто вам не мешает явно написать return None.

# Более того. Ранее мы рассматривали функции, которые вроде бы не возвращали никакого значения,
# потому что в них не было оператора return. На самом деле возвращали, просто мы не обращали на него внимание,
# не присваивали никакой переменной и не выводили на экран. В Python всякая функция что-либо возвращает.
# Если в ней нет оператора return, то она возвращает None. То же самое, как если в ней имеется "пустой" return.


# Возврат нескольких значений
# В Питоне позволительно возвращать из функции несколько объектов, перечислив их через запятую после команды return:

def cylinder():
    r = float(input())
    h = float(input())
    side = 2 * 3.14 * r * h
    circle = 3.14 * r ** 2
    full = side + 2 * circle
    return side, full


sCyl, fCyl = cylinder()
print("Площадь боковой поверхности %.2f" % sCyl)
print("Полная площадь %.2f" % fCyl)
# Из функции cylinder() возвращаются два значения. Первое из них присваивается переменной sCyl,
# второе – fCyl. Возможность такого группового присвоения – особенность Python,
# обычно не характерная для других языков:

>> > a, b, c = 10, 15, 19
>> > a
10
>> > b
15
>> > c
19
# Фокус здесь в том, что перечисление значений через запятую (например, 10, 15, 19) создает объект типа tuple.
# На русский переводится как "кортеж". Это разновидность структур данных, которые будут изучены позже.

# Когда же кортеж присваивается сразу нескольким переменным, то происходит сопоставление его элементов
# соответствующим в очереди переменным. Это называется распаковкой.

# Таким образом, когда из функции возвращается несколько значений,
# на самом деле из нее возвращается один объект класса tuple.
# Перед возвратом эти несколько значений упаковываются в кортеж.
# Если же после оператора return стоит только одна переменная или объект, то ее/его тип сохраняется как есть.

# Распаковка не является обязательной. Будет работать и так:

print(cylinder())
Пример
выполнения:

4
3
(75.36, 175.84)


# На экран выводится кортеж, о чем говорят круглые скобки.
# Его также можно присвоить одной переменной, а потом вывести ее значение на экран.


# !Напишите программу, в которой вызывается функция, запрашивающая с ввода две строки и возвращающая
# в программу результат их конкатенации. Выведите результат на экран.

def concat():
    a = input()
    b = input()
    c = a + b
    return с


print(concat())

#По условию задачи функция должна только возвращать строку, она не должна выводить ее на экран.
#Поэтому решение без return (внизу) не совсем верно:

def concat():
    a = input()
    b = input()
    c = a + b
    print(c)
concat()

#Функцию можно упростить, отказавшись от переменной с


def concat():
    a = input()
    b = input()
    return a + b

print(concat())

#или убираем все переменные


def concat():
    return input() + input()


print(concat())